\section{Task und Mesh Shader}
Die Architektur, auf der die neuartigen RTX-GPUs von Nvidia aufbauen, erweitert die Möglichkeiten, wie die Parallelisierung von GPUs genutzt werden kann.
Mit der GeForce RTX 20er Serie wurden die ersten GPUs mit der Turing Architektur veröffentlicht, die sich auch an Privatpersonen richtet.
Als großer Verkaufspunkt wurde bereits früh mit den Möglichkeiten von Real-time Raytracing und Deep Learning durch Tensor Core geworben \cite{Burgess2020}. 
Eine wesentliche Änderung an der Grafikpipeline wird jedoch bis heute noch relativ wenig Beachtung geschenkt.
Mit dem Shader Model 6 hat NVidia ihre sogenannte "next-generation shading Pipeline" vorgestellt.
Damit wird eine Alternative zur traditionellen Shading Pipeline gestellt, die dem Entwickler mehr Freiheit überlässt, die Parallelisierbarkeit der GPU zu nutzen.
Der Mesh Shader hat die Eigenschaften des Compute Shaders \ref{subsec:compute_shader}, der Daten auf der GPU parallel verarbeiten kann.
Auch Geometrie Daten können mithilfe des Compute Shaders berechnet werden, jedoch ist der Compute Shader kein Teil der traditionellen Grafikpipeline und findet dadurch seinen Nutzen auch außerhalb des Renderings \cite{Ilett2022}.
Mit der \textit{Mesh Shading Pipeline} wurde die Möglichkeit der Parallelisierung des Compute Shaders mit der neuen Rendering Pipeline verknüpft.
Anders als bei der herkömmlichen Grafikpipeline erhält der Mesh Shader seine Daten direkt vom Speicher. 
Dadurch öffnen sich Türen für den Entwickler, da er komprimierte Daten direkt in den GPU Speicher laden kann, um die Daten dann effizienter auf dieser zu dekomprimieren.


\subsection{Meshlets}
\label{subsec:meshlets}
Um die neuartigen Shader für das Rendering zu verwenden, wird empfohlen, das gesamte Mesh in kleinere Subsets, sogenannte Meshlets, zu unterteilen. 
Die traditionelle Grafikpipeline verarbeitet die Daten des Dreiecksnetzes in serieller Manier. 
Dadurch kommt es jedoch zu Bottlenecks.
In der traditionellen Pipeline werden Vertex und Primitiven zugeschnitten und in kleine Clustern verarbeitet.
Dazu wird der Primitive Distributor vor der Vertex Shader Stage aufgerufen.
Dieser liest die Daten des Index Buffers und generiert dementsprechend möglichst performant diese Cluster an Daten.
Der Schritt des Primitive Distributor ist jedoch eine fixed-function Stage der Grafikpipeline, wodurch der Entwickler keinen direkten Zugriff hat.
Das hat zur Folge, dass die Cluster nicht auf die Bedürfnisse des Entwicklers und dessen Implementierung angepasst werden können.
Zuzüglich werden die Cluster zu jedem Frame, bzw. vor jedem Aufruf der Pipeline neu generiert.
Dieser Schritt ist redundant, sollte das Dreiecksnetz zur Laufzeit unverändert bleiben \cite{Carvalho2022}, \cite{Kubisch2018}. \newline

Durch die Compute Shading Natur des Mesh Shaders ist der Input der Daten nicht mehr festgelegt wie bei der traditionellen Pipeline.
Dadurch kann der Entwickler seine eigenen Implementationen zur Generierung von Meshlets verwenden.
Anders als bei der herkömmlichen Grafikpipeline werden Meshlets auf CPU Ebene erstellt.
Dazu werden Vertex Positionen und Indizes benötigt.
Die Anzahl der Vertices und Primitiven muss im Vorfeld festgelegt werden.
Die Auswahl der Meshletgröße ist abhängig von der verwendeten GPU.
So wird im NVidia Blogpost \glqq Introduction to Turing Mesh Shaders\grqq\ eine maximale Anzahl an Vertices von 64, und Primitiven von 126 empfohlen. 
Es werden 126 statt 128 Primitiven empfohlen, da 4 Byte für die Anzahl der Primitiven verwendet werden, die im selben Block Speicher enthalten sein sollen, bzw. keinen weiteren Block beanspruchen sollen \cite{Kubisch2018}.
Arseny Kapoulkine hat verschiedene Meshletgrößen miteinander verglichen.
Er ist zu dem Schluss gekommen, dass 64 Vertices und 84 Primitives am effizientesten ist, insbesondere dann, wenn im Task Shader Culling an den einzelnen Meshlets betrieben wird.
Des weiteren ist die Empfehlung des Blogposts nach eigenen Tests zwar ein guter Maßstab, jedoch wird im Durchschnitt viel Speicher des Primitiven Buffers ungenutzt bleiben, da die 126 Primitiven mit 64 Vertices nie erreicht werden \cite{Kapoulkine2023}.

\subsection{Implementierung Mesh Shader}
\label{subsec:meshshaderimpl}
Wie im vorherigen Unterkapitel angekündigt muss das Dreiecksnetz auf der CPU zu Meshlets geschnitten werden. 
Dazu wurde in dieser Arbeit er Meshoptimizer von Zeux verwendet \cite{Zeux}. 
[Implementierung von Zeux beschreiben]
Die Funktion \glqq meshopt\_buildMeshlets\grqq\ nimmt als Eingabeparameter die maximale Anzahl an Vertices und Primitiven (Kap.\ref{subsec:meshlets}), die Vertex und Index Daten sowie drei leere Buffer.
Der Buffer \textit{meshlet\_indices} wird die neuen Index Daten enthalten, mit denen die Primitiven berechnet werden können.
Der \textit{meshlet\_vertices} Buffer beinhaltet die einzigartigen Vertices des Dreiecksnetzes (Kap~\ref{subsec:primitive_subgroups}).
Der letzte Buffer wird in dieser Arbeit als \textit{Meshlet Descriptor} bezeichnet.
Der Einfachheit halber wird er im Code jedoch einfach als \textit{meshlets} implementiert.
Der Meshlet Buffer setzt sich auch folgenden Elementen zusammen
\begin{itemize}
\item Vertex Count: Die Anzahl der Vertices V in dem Meshlet mit dem Index i
\item Primitive Count: Die Anzahl der Primitives P in dem Meshlet mit dem Index i
\item Vertex Offset: Die Menge an Schritten im Vertex Buffer, um an die Vertices des i-ten Meshlets zu gelangen
\item Primitive Offset: Die Menge an Schritten im Index Buffer um an die Primitives des i-ten Meshlets zu gelangen
\end{itemize}

Mit den Informationen der originalen Vertexdaten und der drei neu generierten Buffer \textit{meshlet\_indices}, \textit{meshlet\_vertices} und \textit{meshlets}, kann nun der Mesh Shader gefüttert werden.
Zunächst müssen die während des Build-Vorgangs kompilierten Shader gelesen werden.
Diese enthalten Informationen zum Layout der Root Signature, die daraufhin per API-Call erstellt wird.
Bevor die Meshlet Daten an den Mesh Shader übergeben werden können, müssen diese in einen GPU Buffer geschrieben werden, damit diese anschließend in den GPU RAM geschrieben werden können.
Wenn das alles gemacht ist können in der Commandlist der Constant Buffer und die benötigten Meshletdaten über die DirectX12 API-Calls SetGraphicsRootConstantBuffer und SetGraphicsRootShaderRessourceView gesetzt werden.

\subsection{Mesh Shader Implementation}
\label{subsec:mesh_shader_impl}
Im Codeabschnitt~\ref{lst:shadercode} ist ein einfacher Mesh Shader zu sehen.
Im Mesh Shader wird die Root Signature entsprechend den Anforderungen gesetzt.
Minimal wird ein StructuredBuffer für jeden der auf der CPU generierten Meshlet Buffer benötigt.
Um dem Endresultat 3-Dimensional wirken zu lassen, wird ein ConstantBuffer verwendet, der die\textit{model}, \textit{modelView} und \textit{modelViewProjection} Matrix beinhaltet. 
Zusätzlich dazu nimmt der Constant Buffer noch ein boolean, um zu steuern, das die Meshlets farbig hervorgehoben werden.
Zunächst wird das aktuelle Meshlet aus dem \textit{Meshlet Descriptor Buffer} genommen.
Die SV\_GroupID stellt in dieser Implementierung den aktuellen Index der Meshlets dar.
Um den lokalen Index des aktuellen Meshlets zu bekommen, muss die SV\_GroupThreadID verwendet werden.
Die aktuelle GroupID wird in einzelne Threads unterteilt, damit die GPU sich bei der parallelen Verarbeitung nicht in die queere kommt.
Die Anzahl der Threads wird mittles \textit{[NumThreads(128, 1, 1)]} im Mesh Shader, oder, falls vorhanden, im Task Shader festgelegt.

\newpage \begin{lstlisting}[language = C++, caption = Mesh Shader Main, label=lst:shadercode]
[RootSignature(ROOT_SIG)]
[NumThreads(128, 1, 1)]
[OutputTopology("triangle")]
void main(
    in uint gtid : SV_GroupThreadID,
    in uint gid : SV_GroupID,
    out vertices VertexOut verts[64],
    out indices uint3 tris[84]
)
{
  Meshlet m = Meshlets[gid];
  uint3 primitive;

  SetMeshOutputCounts(m.VertCount, m.PrimCount);
  
  if (gtid < m.PrimCount)
  {
    primitive = GetPrimitive(m, gtid);
    tris[gtid] = primitive;
  }
  
  if (gtid < m.VertCount)
  {
    uint vertexIndex = GetVertexIndex(m, primitive[0]);
    verts[gtid] = GetVertex(gid, vertexIndex);
  }
}
\end{lstlisting}

\subsection{Das auf der GPU zu dekodierende Binärformat}
\label{subsec:binary_format}
[Eventuell nicht als eigenes Unterkapitel]
