% Encoding: UTF-8

@Article{Jakob2017,
  author   = {Jakob, Johannes and Buchenau, Christoph and Guthe, Michael},
  journal  = {Computer Graphics Forum},
  title    = {A Parallel Approach to Compression and Decompression of Triangle Meshes using the GPU},
  year     = {2017},
  number   = {5},
  pages    = {71-80},
  volume   = {36},
  abstract = {Abstract Most state-of-the-art compression algorithms use complex connectivity traversal and prediction schemes, which are not efficient enough for online compression of large meshes. In this paper we propose a scalable massively parallel approach for compression and decompression of large triangle meshes using the GPU. Our method traverses the input mesh in a parallel breadth-first manner and encodes the connectivity data similarly to the well known cut-border machine. Geometry data is compressed using a local prediction strategy. In contrast to the original cut-border machine, we can additionally handle triangle meshes with inconsistently oriented faces. Our approach is more than one order of magnitude faster than currently used methods and achieves competitive compression rates.},
  doi      = {https://doi.org/10.1111/cgf.13246},
  eprint   = {https://onlinelibrary.wiley.com/doi/pdf/10.1111/cgf.13246},
  keywords = {Categories and Subject Descriptors (according to ACM CCS), I.3.6 Computer Graphics: Methodology and Techniques—Graphics data structures and data types, I.3.5 Computer Graphics: Computational Geometry and Object Modeling—Geometric algorithms, languages, and systems, I.3.1 Computer Graphics: Hardware Architecture—Parallel processing},
  url      = {https://onlinelibrary.wiley.com/doi/abs/10.1111/cgf.13246},
}

@Article{Kubisch2018,
  author = {Christoph Kubisch},
  title  = {Introduction to Turing Mesh Shaders},
  year   = {2018},
  url    = {https://developer.nvidia.com/blog/introduction-turing-mesh-shaders/#entry-content-comments},
}

@Article{Kapoulkine2023,
  author = {Arseny Kapoulkine},
  title  = {Meshlet size tradeoffs},
  year   = {2023},
  url    = {https://zeux.io/2023/01/16/meshlet-size-tradeoffs/},
}

@Article{Burgess2020,
  author   = {Burgess, John},
  journal  = {IEEE Micro},
  title    = {RTX on—The NVIDIA Turing GPU},
  year     = {2020},
  number   = {2},
  pages    = {36-44},
  volume   = {40},
  doi      = {10.1109/MM.2020.2971677},
  keywords = {Graphics processing units;Ray tracing;Tensors;Multiprocessors;Random access memory;Deep learning;Instruction sets;I.3.1.a Graphics processors < I.3.1 Hardware Architecture < I.3 Computer Graphics < I Computing Methodologies;C.1.2.i TC scheduling and synchronization < C.1.2 Multiple Data Stream Architectures (Multiprocessors) < C.1 Processor Architect;C.1.4.e Multi-core/single-chip multiprocessors < C.1.4 Parallel Architectures < C.1 Processor Architectures < C Computer Systems;Deep learning;Ray tracing;GPU;Turing;Tensor Core;RTCore;SIMT},
}

@Article{Carvalho2022,
  author = {Miguel Ângelo Abreu de Carvalho},
  title  = {Exploring Mesh Shaders},
  year   = {2022},
}

@InBook{Ilett2022,
  author    = {Ilett, Daniel},
  pages     = {517--582},
  publisher = {Apress},
  title     = {Advanced Shaders},
  year      = {2022},
  address   = {Berkeley, CA},
  isbn      = {978-1-4842-8652-4},
  abstract  = {So far, we have primarily discussed vertex and fragment shaders that take meshes, transform their vertices onto the screen, and color the pixels. Most shaders take this form. We've already seen the power of these types of shaders and the broad range of capabilities they have, but they are not the only types of shaders. In the shader pipeline, there are two optional stages that we have not yet encountered: the tessellation shader and the geometry shader. On top of that, there are compute shaders, which operate outside the usual mesh shading pipeline and can be used for arbitrary calculations on the GPU. In this chapter, we will explore some of these strange and exotic new types of shaders and add ever-powerful new tools to our box of tricks.},
  booktitle = {Building Quality Shaders for Unity®: Using Shader Graphs and HLSL Shaders},
  doi       = {10.1007/978-1-4842-8652-4_12},
  url       = {https://doi.org/10.1007/978-1-4842-8652-4_12},
}

@Article{Zeux,
  author = {Zeux},
  title  = {meshoptimizer},
  url    = {https://github.com/zeux/meshoptimizer},
}

@Inbook{DalCin1996,
author="Dal Cin, Mario",
title="Klassifizierung von Rechnerarchitekturen",
bookTitle="Rechnerarchitektur: Grundz{\"u}ge des Aufbaus und der Organisation von Rechnerhardware",
year="1996",
publisher="Vieweg+Teubner Verlag",
address="Wiesbaden",
pages="22--32",
abstract="„Eine Klassifizierung zerlegt eine Menge von Objekten in Klassen aufgrund geeignet gew{\"a}hlter Merkmale und es mu{\ss} dabei weder eine Hierarchie noch eine Ordnung begr{\"u}ndet werden. Mit anderen Worten: Der Zweck einer Klassifizierung ist erf{\"u}llt, wenn ann{\"a}hernd gleiche Objekte der gleichen Klasse und hinreichend verschiedene Objekte verschiedenen Klassen zugewiesen werden`` W. Giloi [Gilo93].",
isbn="978-3-322-94769-7",
doi="10.1007/978-3-322-94769-7_2",
url="https://doi.org/10.1007/978-3-322-94769-7_2"
}

@Article{article,
  author  = {Lehmann, Moritz and Krause, Mathias and Amati, Giorgio and Sega, Marcello and Harting, Jens and Gekle, Stephan},
  journal = {Physical Review E},
  title   = {Accuracy and performance of the lattice Boltzmann method with 64-bit, 32-bit, and customized 16-bit number formats},
  year    = {2022},
  month   = {07},
  volume  = {106},
  doi     = {10.1103/PhysRevE.106.015308},
}

@Book{cozzi2012opengl,
  author    = {Cozzi, P. and Riccio, C.},
  publisher = {Taylor \& Francis},
  title     = {OpenGL Insights},
  year      = {2012},
  isbn      = {9781439893760},
  series    = {Online access with subscription: Proquest Ebook Central},
  lccn      = {2012019338},
  url       = {https://books.google.de/books?id=CCVenzOGjpcC},
}

@Article{Compute24,
  author  = {OpenGL},
  journal = {OpenGL Wiki},
  title   = {Compute Shader},
  year    = {(besucht am 09.02.2024)},
  url     = {https://www.khronos.org/opengl/wiki/Compute_Shader},
}

@Article{BrotliG2022,
  author  = {AMD},
  journal = {AMD GPUOpen},
  title   = {Brotli-G: An open-source compression/decompression standard for digital assets that is compatible with GPU hardware},
  year    = {2022},
  url     = {https://gpuopen.com/brotli-g-sdk-announce/},
}

@Article{Alakuijala2019,
  author  = {Jyrki Alakuijala and Andrea Farruggia and Paolo Ferragina and Evgenii Kliuchnikov and Robert Obryk and Zoltan Szabadka and Lode Vandevenne},
  journal = {ACM Transactions on Information Systems},
  title   = {Brotli: A General-Purpose Data Compressor},
  year    = {2019},
  url     = {https://dl.acm.org/citation.cfm?id=3231935},
}

@Article{lz2023,
  author  = {Microsoft},
  journal = {Microsoft Documentation},
  title   = {LZ77 Compression Algorithm},
  year    = {2023},
  url     = {https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-wusp/fb98aa28-5cd7-407f-8869-a6cef1ff1ccb},
}

@Article{Microsoft2021,
  author  = {Microsoft},
  journal = {Microsoft Documentation},
  title   = {Typed Unordered Access Views (UAV)},
  year    = {2021},
}

@Article{Moffat2019,
  author     = {Moffat, Alistair},
  journal    = {ACM Comput. Surv.},
  title      = {Huffman Coding},
  year       = {2019},
  issn       = {0360-0300},
  month      = {aug},
  number     = {4},
  volume     = {52},
  abstract   = {Huffman’s algorithm for computing minimum-redundancy prefix-free codes has almost legendary status in the computing disciplines. Its elegant blend of simplicity and applicability has made it a favorite example in algorithms courses, and as a result it is perhaps one of the most commonly implemented algorithmic techniques. This article presents a tutorial on Huffman coding and surveys some of the developments that have flowed as a consequence of Huffman’s original discovery, including details of code calculation and of encoding and decoding operations. We also survey related mechanisms, covering both arithmetic coding and the recently developed asymmetric numeral systems approach and briefly discuss other Huffman-coding variants, including length-limited codes.},
  address    = {New York, NY, USA},
  articleno  = {85},
  doi        = {10.1145/3342555},
  issue_date = {July 2020},
  keywords   = {Huffman code, data compression, minimum-redundancy code},
  numpages   = {35},
  publisher  = {Association for Computing Machinery},
  url        = {https://doi.org/10.1145/3342555},
}

@InProceedings{Choudhary2015,
  author = {Suman M. Choudhary and Anjali S. Patel and Sonal J. Parmar},
  title  = {Study of LZ 77 and LZ 78 Data Compression Techniques},
  year   = {2015},
  url    = {https://api.semanticscholar.org/CorpusID:212549082},
}

@Article{Jensen2023,
  author  = {Jensen Mark Bo and Frisvad, Jeppe Revall and Bærentzen, J. Andreas},
  journal = {Journal of Computer Graphics Techniques},
  title   = {Performance Comparison of Meshlet Generation Strategies},
  year    = {2023},
}

@Article{Jobalia2019,
  author  = {Sarah Jobalia},
  journal = {DirectX Developer Blog},
  title   = {Coming to DirectX 12— Mesh Shaders and Amplification Shaders: Reinventing the Geometry Pipeline},
  year    = {2019},
  url     = {https://devblogs.microsoft.com/directx/coming-to-directx-12-mesh-shaders-and-amplification-shaders-reinventing-the-geometry-pipeline/},
}

@Article{Jeon1998,
  author   = {Byeungwoo Jeon and Juha Park and Jechang Jeong},
  journal  = {Signal Processing: Image Communication},
  title    = {Huffman coding of DCT coefficients using dynamic codeword assignment and adaptive codebook selection},
  year     = {1998},
  issn     = {0923-5965},
  number   = {3},
  pages    = {253-262},
  volume   = {12},
  abstract = {In many image sequence compression applications, Huffman coding is used to eliminate statistical redundancy resident in given data. The Huffman table is often pre-defined to reduce coding delay and table transmission overhead. Local symbol statistics, however, may be much different from the global ones manifested in the pre-defined table. In this paper, we propose three Huffman coding methods in which pre-defined codebooks are effectively manipulated according to local symbol statistics. The first proposed method dynamically modifies the symbol-codeword association without rebuilding the Huffman tree itself. The encoder and decoder maintain identical symbol-codeword association by performing the same modifications to the Huffman table, thus eliminating extra transmission overhead. The second method adaptively selects a codebook from a set of given ones, which produces the minimum number of bits. The transmission overhead in this method is the codebook selection information, which is observed to be negligible compared with the bit saving attained. Finally, we combine the two aforementioned methods to further improve compression efficiency. Experiments are carried out using five test image sequences to demonstrate the compression performance of the proposed methods.},
  doi      = {https://doi.org/10.1016/S0923-5965(97)00041-6},
  keywords = {Huffman coding, Dynamic Huffman coding, Re-association, Compression},
  url      = {https://www.sciencedirect.com/science/article/pii/S0923596597000416},
}

@Comment{jabref-meta: databaseType:bibtex;}
